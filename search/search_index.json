{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Build your best UI. <p>         Fusion is a modern reactive UI library, built specifically for         Roblox         and         Luau.     </p> <p>         Build your UI with a declarative syntax that's easy to read and write.         Plug in live data with simple, flexible, truly reactive state management.         Deliver a fast, smooth experience to everyone - on mobile, console, PC or in VR.     </p> Get started Download latest Declarative UI syntax <p>         Fusion provides a natural, easy to read syntax, so you can focus on what         your UI should look like, without worrying about the implementation.     </p> <p>         Focus on the properties and children in your UI, not verbose APIs.     </p> <pre><code>return New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    [Children] = New \"TextButton\" {\n        Position = UDim2.fromScale(.5, .5)\n        AnchorPoint = Vector2.new(.5, .5),\n        Size = UDim2.fromOffset(200, 50),\n\n        Text = \"Fusion is fun :)\",\n\n        [OnEvent \"Activated\"] = function()\n            print(\"Clicked!\")\n        end\n    }\n}\n</code></pre> Reactive state management <p>         Fluidly write all your calculations, and they'll be automatically run as         your variables change.     </p> <p>         Fusion accelerates and optimises all of your computations for you.     </p> <pre><code>local numCoins = State(10)\n\nlocal doubleCoins = Computed(function()\n    return numCoins:get() * 2\nend)\n\nlocal coinsMessage = Computed(function()\n    return \"You have \" .. numCoins:get() .. \" coins.\"\nend)\n\nreturn New \"TextLabel\" {\n    Text = coinsMessage\n}\n</code></pre> Animate everything <p>         Bring your UI to life with the simplest, most universal animation tools         of any Roblox library. Access tweens and springs with one line of code.     </p> <p>         Animate anything instantly, no refactoring or performance tricks required.     </p> <pre><code>local playerCount = State(100)\nlocal position = State(UDim2.new(0, 0, 0, 0))\n\nlocal smoothCount = Tween(playerCount, TweenInfo.new(0.5))\n\nreturn New \"TextLabel\" {\n    Position = Spring(position, 25, 0.2),\n\n    Text = Computed(function()\n        return \"Players online: \" .. math.floor(smoothCount:get())\n    end)\n}\n</code></pre> Fusion is built with performance in mind, from idea to implementation. <p>         From top-end desktop PCs to budget phones from years ago, Fusion         delivers an exceptionally light, fluid experience as standard.     </p> <p>         Build your most beautiful, bold, animated interfaces with confidence -         Fusion scales to high-refresh-rate devices and VR effortlessly.     </p> Get up and running with Fusion in minutes. <p>         Downloading and importing Fusion into Studio is quick, easy and 100%         free.     </p> <p>         The Fusion starter tutorials are aimed at a wide range of creators, from         seasoned UI developers to novice scripters.     </p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Fusion is a modern reactive UI library, designed and built for Roblox and Luau. Here, you can find documentation for every public API exposed by the Fusion module.</p>"},{"location":"api-reference/#navigation","title":"Navigation","text":"<p>Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.</p>"},{"location":"api-reference/#type-information","title":"Type Information","text":"<p>On many API pages, you'll see type annotations describing the API member. For example:</p> <pre><code>function New(className: string): (props: {[string | Symbol]: any}) -&gt; Instance\n</code></pre> <p>While these type annotations are designed to be Luau-like, they are ultimately psuedocode included as a developer aid. For fully accurate and syntactically valid type information, please refer to the source code directly.</p>"},{"location":"api-reference/#commonly-used","title":"Commonly Used","text":"<p>Jump directly to the documentation for some common APIs:</p>"},{"location":"api-reference/#instances","title":"Instances","text":"<ul> <li>New</li> </ul>"},{"location":"api-reference/#state-management","title":"State Management","text":"<ul> <li>State</li> <li>Computed</li> <li>ComputedPairs</li> </ul>"},{"location":"api-reference/#animation","title":"Animation","text":"<ul> <li>Tween</li> <li>Spring</li> </ul>"},{"location":"api-reference/errors-and-messages/","title":"Errors & Messages","text":"<p>If your code isn't working properly, or if Fusion is malfunctioning, you may see some errors being printed to the output. Each message comes with a unique ID at the end.</p> <p>On this page, you can learn more about any error messages you're receiving.</p>"},{"location":"api-reference/errors-and-messages/#cannotassignproperty","title":"<code>cannotAssignProperty</code>","text":"<pre><code>The class type 'Foo' has no assignable property 'Bar'.\n</code></pre> <p>This message shows if you try to assign a non-existent or locked property using the New function:</p> <pre><code>local folder = New \"Folder\" {\n    DataCost = 12345,\n    ThisPropertyDoesntExist = \"Example\"\n}\n</code></pre> <p>Tip</p> <p>Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties!</p>"},{"location":"api-reference/errors-and-messages/#cannotconnectchange","title":"<code>cannotConnectChange</code>","text":"<pre><code>The Frame class doesn't have a property called 'Foo'.\n</code></pre> <p>This message shows if you try to connect a handler to a non-existent property change event when using the New function:</p> <pre><code>local textBox = New \"TextBox\" {\n    [OnChange \"ThisPropertyDoesntExist\"] = function()\n        ...\n    end)\n}\n</code></pre>"},{"location":"api-reference/errors-and-messages/#cannotconnectevent","title":"<code>cannotConnectEvent</code>","text":"<pre><code>The Frame class doesn't have an event called 'Foo'.\n</code></pre> <p>This message shows if you try to connect a handler to a non-existent event when using the New function:</p> <pre><code>local button = New \"TextButton\" {\n    [OnEvent \"ThisEventDoesntExist\"] = function()\n        ...\n    end)\n}\n</code></pre>"},{"location":"api-reference/errors-and-messages/#cannotcreateclass","title":"<code>cannotCreateClass</code>","text":"<pre><code>Can't create a new instance of class 'Foo'.\n</code></pre> <p>This message shows when using the New function with an invalid class type:</p> <pre><code>local instance = New \"ThisClassTypeIsInvalid\" {\n    ...\n}\n</code></pre>"},{"location":"api-reference/errors-and-messages/#computedcallbackerror","title":"<code>computedCallbackError</code>","text":"<pre><code>Computed callback error: attempt to index a nil value\n</code></pre> <p>This message shows when the callback of a computed object encounters an error:</p> <pre><code>local example = Computed(function()\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#invalidspringdamping","title":"<code>invalidSpringDamping</code>","text":"<pre><code>The damping ratio for a spring must be &gt;= 0. (damping was -0.50)\n</code></pre> <p>This message shows if you try to provide a damping ratio to a spring which is less than 0:</p> <pre><code>local speed = 10\nlocal damping = -12345\nlocal spring = Spring(state, speed, damping)\n</code></pre> <p>Damping ratio must always be between 0 and infinity for a spring to be physically simulatable.</p>"},{"location":"api-reference/errors-and-messages/#invalidspringspeed","title":"<code>invalidSpringSpeed</code>","text":"<pre><code>The speed of a spring must be &gt;= 0. (speed was -2.00)\n</code></pre> <p>This message shows if you try to provide a speed to a spring which is less than 0:</p> <pre><code>local speed = -12345\nlocal spring = Spring(state, speed)\n</code></pre> <p>Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible.</p>"},{"location":"api-reference/errors-and-messages/#mistypedspringdamping","title":"<code>mistypedSpringDamping</code>","text":"<pre><code>The damping ratio for a spring must be a number. (got a boolean)\n</code></pre> <p>This message shows if you try to provide a damping ratio to a spring which isn't a number:</p> <pre><code>local speed = 10\nlocal damping = true\nlocal spring = Spring(state, speed, damping)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#mistypedspringspeed","title":"<code>mistypedSpringSpeed</code>","text":"<pre><code>The speed of a spring must be a number. (got a boolean)\n</code></pre> <p>This message shows if you try to provide a speed to a spring which isn't a number:</p> <pre><code>local speed = true\nlocal spring = Spring(state, speed)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#mistypedtweeninfo","title":"<code>mistypedTweenInfo</code>","text":"<pre><code>The tween info of a tween must be a TweenInfo. (got a boolean)\n</code></pre> <p>This message shows if you try to provide a tween info to a tween which isn't a TweenInfo:</p> <pre><code>local tweenInfo = true\nlocal tween = Tween(state, tweenInfo)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#pairsdestructorerror","title":"<code>pairsDestructorError</code>","text":"<pre><code>ComputedPairs destructor error: attempt to index a nil value\n</code></pre> <p>This message shows when the <code>destructor</code> callback of a ComputedPairs object encounters an error:</p> <pre><code>local example = ComputedPairs(\n    data,\n    processor,\n    function(value)\n        local badMath = 2 + \"fish\"\n    end\n)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#pairsprocessorerror","title":"<code>pairsProcessorError</code>","text":"<pre><code>ComputedPairs callback error: attempt to index a nil value\n</code></pre> <p>This message shows when the <code>processor</code> callback of a ComputedPairs object encounters an error:</p> <pre><code>local example = ComputedPairs(data, function(key, value)\n    local badMath = 2 + \"fish\"\nend)\n</code></pre>"},{"location":"api-reference/errors-and-messages/#springtypemismatch","title":"<code>springTypeMismatch</code>","text":"<pre><code>The type 'number' doesn't match the spring's type 'Color3'.\n</code></pre> <p>Some methods on spring objects require incoming values to match the types previously being used on the spring.</p> <p>This message shows when an incoming value doesn't have the same type as values used previously on the spring:</p> <pre><code>local colour = State(Color3.new(1, 0, 0))\nlocal colourSpring = Spring(colour)\n\ncolourSpring:addVelocity(Vector2.new(2, 3))\n</code></pre>"},{"location":"api-reference/errors-and-messages/#strictreaderror","title":"<code>strictReadError</code>","text":"<pre><code>'Foo' is not a valid member of 'Bar'.\n</code></pre> <p>In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos.</p> <p>This message shows when trying to read a non-existent member of these tables.</p>"},{"location":"api-reference/errors-and-messages/#unknownmessage","title":"<code>unknownMessage</code>","text":"<pre><code>Unknown error: attempt to index a nil value\n</code></pre> <p>If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed.</p> <p>When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one.</p>"},{"location":"api-reference/errors-and-messages/#unrecognisedchildtype","title":"<code>unrecognisedChildType</code>","text":"<pre><code>'number' type children aren't accepted as children in `New`.\n</code></pre> <p>This message shows when attempting to pass something as a child which isn't an instance, table of instances, or state object containing an instance (when using the New function):</p> <pre><code>local instance = New \"Folder\" {\n    [Children] = {\n        1, 2, 3, 4, 5,\n\n        {true, false},\n\n        State(Enum.Material.Grass)\n    }\n}\n</code></pre> <p>Note</p> <p>Note that state objects are allowed to store <code>nil</code> to represent the absence of an instance, as an exception to these rules.</p>"},{"location":"api-reference/errors-and-messages/#unrecognisedpropertykey","title":"<code>unrecognisedPropertyKey</code>","text":"<pre><code>'number' keys aren't accepted in the property table of `New`.\n</code></pre> <p>When you create an instance in Fusion using New, you can pass in a 'property table' containing properties, children, event and property change handlers, etc.</p> <p>This table is only expected to contain keys of two types:</p> <ul> <li>string keys, e.g. <code>Name = \"Example\"</code></li> <li>a few symbol keys, e.g. <code>[OnEvent \"Foo\"] = ...</code></li> </ul> <p>This message shows if Fusion finds a key of a different type, or if the key isn't one of the few symbol keys used in New:</p> <pre><code>local folder = New \"Folder\" {\n    [Vector3.new()] = \"Example\",\n\n    \"This\", \"Shouldn't\", \"Be\", \"Here\"\n}\n</code></pre>"},{"location":"api-reference/api/children/","title":"Children","text":"<pre><code>local Children: Symbol\n</code></pre> <p>The symbol used to denote the children of an instance when working with the New function.</p> <p>When using this symbol as a key in <code>New</code>'s property table, the values will be treated as children, and parented according to the rules below.</p>"},{"location":"api-reference/api/children/#example-usage","title":"Example Usage","text":"<pre><code>local example = New \"Folder\" {\n    [Children] = New \"StringValue\" {\n        Value = \"I'm parented to the Folder!\"\n    }\n}\n</code></pre>"},{"location":"api-reference/api/children/#processing-children","title":"Processing Children","text":"<p>A 'child' is defined (recursively) as:</p> <ul> <li>an instance</li> <li>a state object or computed object containing children</li> <li>an array of children</li> </ul> <p>Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid:</p> <pre><code>local example = New \"Folder\" {\n    [Children] = {\n        {\n            {\n                New \"StringValue\" {\n                    Value = \"I'm parented to the Folder!\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it:</p> <pre><code>local function Component(props)\n    return {\n        New \"TextLabel\" {\n            LayoutOrder = 1,\n            Text = \"Instance one\"\n        },\n\n        New \"TextLabel\" {\n            LayoutOrder = 2,\n            Text = \"Instance two\"\n        }\n    }\nend\n\nlocal parent = New \"Frame\" {\n    Children = {\n        New \"UIListLayout\" {\n            SortOrder = \"LayoutOrder\"\n        },\n\n        Component {}\n    }\n}\n</code></pre> <p>When using a state or computed object as a child, it will be bound; when the value of the state object changes, it'll unparent the old children and parent the new children.</p> <p>Note</p> <p>As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away.</p> <pre><code>local child1 = New \"Folder\" {\n    Name = \"Child one\"\n}\nlocal child2 = New \"Folder\" {\n    Name = \"Child two\"\n}\n\nlocal childState = State(child1)\n\nlocal parent = New \"Folder\" {\n    [Children] = childState\n}\n\nprint(parent:GetChildren()) -- { Child one }\n\nchildState:set(child2)\nwait(1) -- wait for deferred updates to run\n\nprint(parent:GetChildren()) -- { Child two }\n</code></pre> <p>Warning</p> <p>When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed.</p> <p>If you're using a helper like ComputedPairs, instance cleanup is handled for you by default (though this is configurable).</p>"},{"location":"api-reference/api/compat/","title":"Compat","text":"<pre><code>function Compat(watchedState: State&lt;any&gt;): Compat\n</code></pre> <p>Constructs and returns a new compatibility object, which will listen for events on the given <code>watchedState</code> object.</p> <p>Compat is intended as an API for integrating Fusion with other, non-Fusion code. Some example uses include synchronising theme colours to non-Fusion UIs, or saving state objects to data stores as they change.</p> <p>Warning</p> <p>You should only use <code>Compat</code> when dealing with non-Fusion code.</p> <p>If you're building an interface with Fusion, there are already reactive tools for almost every single use case, which can be better optimised by Fusion and lead to cleaner and more idiomatic code. Using <code>Compat</code> in these situations is highly discouraged.</p> <p>Changing state objects in <code>:onChange()</code> is a particular anti-pattern which abusing Compat may encourage. If you need to update the value of a state object when another state object is changed, consider using computed state instead.</p> <p>For further details, see this issue on GitHub.</p>"},{"location":"api-reference/api/compat/#parameters","title":"Parameters","text":"<ul> <li><code>watchedState: State&lt;any&gt;</code> - a state object, computed object or other state object to track.</li> </ul>"},{"location":"api-reference/api/compat/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/compat/#onchange","title":"<code>onChange()</code>","text":"<p><pre><code>function Compat:onChange(callback: () -&gt; ()): () -&gt; ()\n</code></pre> Connects the given callback as a change handler, and returns a function which will disconnect the callback.</p> <p>When the value of this Compat's <code>watchedState</code> changes, the callback will be fired.</p> <p>Connection memory leaks</p> <p>Make sure to disconnect any change handlers made using this function once you're done using them.</p> <p>As long as a change handler is connected, this Compat object (and the <code>watchedState</code>) will be held in memory so changes can be detected. This means that, if you don't call the disconnect function, you may end up accidentally holding the state object in memory after you're done using them.</p>"},{"location":"api-reference/api/compat/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = State(50)\n\nlocal compat = Compat(numCoins)\n\nlocal disconnect = compat:onChange(function()\n    print(\"coins is now:\", numCoins:get())\nend)\n\nnumCoins:set(25) -- prints 'coins is now: 25'\n\n-- always clean up your connections!\ndisconnect()\n</code></pre>"},{"location":"api-reference/api/computed/","title":"Computed","text":"<pre><code>function Computed(callback: () -&gt; any): Computed\n</code></pre> <p>Constructs and returns a new computed object, using the given callback to compute this object's values based on other state objects or computed objects.</p>"},{"location":"api-reference/api/computed/#parameters","title":"Parameters","text":"<ul> <li><code>callback: () -&gt; any</code> - a function which computes and returns the value to use for this computed object.</li> </ul>"},{"location":"api-reference/api/computed/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/computed/#get","title":"<code>get()</code>","text":"<p><pre><code>function Computed:get(): any\n</code></pre> Returns the cached value of this computed object, as returned from the callback function.</p> <p>If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.</p>"},{"location":"api-reference/api/computed/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = State(50)\n\nlocal doubleCoins = Computed(function()\n    return numCoins:get() * 2\nend)\n\nprint(doubleCoins:get()) --&gt; 100\n\nnumCoins:set(2)\nprint(doubleCoins:get()) --&gt; 4\n</code></pre>"},{"location":"api-reference/api/computed/#dependency-management","title":"Dependency Management","text":"<p>Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like <code>:get()</code> on a state object, it will register that state object as a dependency:</p> <pre><code>local numCoins = State(50)\n\nlocal doubleCoins = Computed(function()\n    -- Fusion detects we called :get() on `numCoins`, and so adds `numCoins` as\n    -- a dependency of this computed object.\n    return numCoins:get() * 2\nend)\n</code></pre> <p>When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the <code>:get()</code> method.</p> <p>Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates:</p> Lua <pre><code>local stateA = State(5)\nlocal stateB = State(5)\nlocal selector = State(\"A\")\n\nlocal computed = Computed(function()\n    print(\"&gt; updating computed!\")\n    local selected = selector:get()\n    if selected == \"A\" then\n        return stateA:get()\n    elseif selected == \"B\" then\n        return stateB:get()\n    end\nend)\n\nprint(\"increment state A (expect update below)\")\nstateA:set(stateA:get() + 1)\nprint(\"increment state B (expect no update)\")\nstateA:set(stateA:get() + 1)\n\nprint(\"switch to select B\")\nselector:set(\"B\")\n\nprint(\"increment state A (expect no update)\")\nstateA:set(stateA:get() + 1)\nprint(\"increment state B (expect update below)\")\nstateA:set(stateA:get() + 1)\n</code></pre> Expected output <pre><code>&gt; updating computed!\nincrement state A (expect update below)\n&gt; updating computed!\nincrement state B (expect no update)\nswitch to select B\n&gt; updating computed!\nincrement state A (expect no update)\nincrement state B (expect update below)\n&gt; updating computed!\n</code></pre> <p>Danger</p> <p>Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes.</p> <p>Fusion can't automatically detect changes when you use 'normal' variables:</p> <pre><code>local theVariable = \"Hello\"\nlocal badValue = Computed(function()\n    -- don't do this! use state objects or computed objects in here\n    return \"Say \" .. theVariable\nend)\n\nprint(badValue:get()) -- prints 'Say Hello'\n\ntheVariable = \"World\"\nprint(badValue:get()) -- still prints 'Say Hello' - that's a problem!\n</code></pre> <p>By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object:</p> <pre><code>local theVariable = State(\"Hello\")\nlocal goodValue = Computed(function()\n    -- this is much better - Fusion can detect we used this state object!\n    return \"Say \" .. theVariable:get()\nend)\n\nprint(goodValue:get()) -- prints 'Say Hello'\n\ntheVariable:set(\"World\")\nprint(goodValue:get()) -- prints 'Say World'\n</code></pre> <p>This also applies to any functions that change on their own, like <code>os.clock()</code>. If you need to use them, store values from the function in a state object, and update the value of that object as often as required.</p>"},{"location":"api-reference/api/computedpairs/","title":"ComputedPairs","text":"<pre><code>function ComputedPairs(\n    inputTable: StateOrValue&lt;{[any]: any}&gt;,\n    processor: (key: any, value: any) -&gt; any,\n    destructor: ((any) -&gt; any)?\n): Computed\n</code></pre> <p>Constructs and returns a new computed object, which generates a table by processing values from another table.</p> <p>The input table may be passed in directly, or inside a state object or computed object.</p> <p>The output table will have all the keys of the input table, but all the values will be passed through the <code>processor</code> function.</p> <p>When values are removed from the output table, they may optionally be passed through a <code>destructor</code> function. This allows you to properly clean up some types such as instances - more details can be found in the tutorial.</p>"},{"location":"api-reference/api/computedpairs/#parameters","title":"Parameters","text":"<ul> <li><code>inputTable: StateOrValue&lt;{[any]: any}&gt;</code> - a table, or state object containing a table, which will be read by this ComputedPairs</li> <li><code>processor: (key: any, value: any) -&gt; any</code> - values from the input table will be passed through this function and placed in the table returned by this object</li> <li><code>destructor: ((any) -&gt; any)?</code> - when a value is removed from the output table, it will be passed to this function for cleanup. If not provided, defaults to a Maid-like cleanup function.</li> </ul>"},{"location":"api-reference/api/computedpairs/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/computedpairs/#get","title":"<code>get()</code>","text":"<p><pre><code>function ComputedPairs:get(): any\n</code></pre> Returns the cached value of this computed object, which will be the output table of key/value pairs.</p> <p>If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.</p>"},{"location":"api-reference/api/computedpairs/#example-usage","title":"Example Usage","text":"<pre><code>local playerList = State({\n    \"AxisAngles\",\n    \"boatbomber\",\n    \"Elttob\",\n    \"grilme99\",\n    \"Phalanxia\",\n    \"Reselim\",\n    \"thisfall\"\n})\n\nlocal textLabels = ComputedPairs(playerList, function(key, value)\n    return New \"TextLabel\" {\n        Text = value\n    }\nend)\n</code></pre>"},{"location":"api-reference/api/new/","title":"New","text":"<pre><code>function New(className: string): (props: {[string | Symbol]: any}) -&gt; Instance\n</code></pre> <p>Constructs and returns a new instance, with options for setting properties, event handlers and other attributes on the instance right away.</p> <p>The function has curried parameters - when calling <code>New</code> with the <code>className</code> parameter, it'll return a second function accepting the <code>props</code> parameter. This is done to take advantage of some function call syntax sugar in Lua:</p> <pre><code>local myInstance = New(\"Frame\")({...})\n-- is equivalent to:\nlocal myInstance = New \"Frame\" {...}\n</code></pre> <p>Instance cleanup</p> <p>Make sure to destroy your instances properly. Without using an explicit <code>:Destroy()</code>, it's easy to accidentally introduce memory leaks.</p> <p>For lists of instances, you can use ComputedPairs, which comes with good defaults for instance caching and cleanup.</p>"},{"location":"api-reference/api/new/#parameters","title":"Parameters","text":"<ul> <li><code>className: string</code> - the class type of instance to create</li> <li><code>props: {[string | Symbol]: any}</code> - a table of properties, event handlers and other attributes to apply to the instance</li> </ul>"},{"location":"api-reference/api/new/#example-usage","title":"Example Usage","text":"<pre><code>local myButton: TextButton = New \"TextButton\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Position = UDim2.fromScale(.5, .5),\n    AnchorPoint = Vector2.new(.5, .5),\n    Size = UDim2.fromOffset(200, 50),\n\n    Text = \"Hello, world!\",\n\n    [OnEvent \"Activated\"] = function()\n        print(\"The button was clicked!\")\n    end,\n\n    [OnChange \"Name\"] = function(newName)\n        print(\"The button was renamed to:\", newName)\n    end,\n\n    [Children] = New \"UICorner\" {\n        CornerRadius = UDim.new(0, 8)\n    }\n}\n</code></pre>"},{"location":"api-reference/api/new/#passing-in-properties","title":"Passing In Properties","text":"<p>The <code>props</code> table uses a mix of string and symbol keys to specify attributes of the instance which should be set.</p> <p>String keys are treated as property declarations - values passed in will be set upon the instance:</p> <pre><code>local example = New \"Part\" {\n    -- sets the Position property\n    Position = Vector3.new(1, 2, 3)\n}\n</code></pre> <p>Additionally, passing in state objects or computed objects will bind the property value; when the value of the object changes, the property will also update on the next render step:</p> <pre><code>local myName = State(\"Bob\")\n\nlocal example = New \"Part\" {\n    -- initially, the Name will be set to Bob\n    Name = myName\n}\n\n-- change the state object to store \"John\"\n-- on the next render step, the part's Name will change to John\nmyName:set(\"John\")\n</code></pre> <p>Fusion provides additional symbol keys for other, specialised purposes - see their documentation for more info on how each one works:</p> <ul> <li>Children - parents other instances into this instance</li> <li>OnEvent - connects a callback to an event on this instance</li> <li>OnChange - connects a callback to the <code>GetPropertyChangedSignal</code> event for a property on this instance</li> </ul>"},{"location":"api-reference/api/new/#default-properties","title":"Default Properties","text":"<p>The <code>New</code> function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults.</p> <p>You can see the default properties Fusion uses here:</p> Default properties <pre><code>ScreenGui = {\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\"\n},\n\nBillboardGui = {\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\"\n},\n\nSurfaceGui = {\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    SizingMode = \"PixelsPerStud\",\n    PixelsPerStud = 50\n},\n\nFrame = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0\n},\n\nScrollingFrame = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0,\n\n    ScrollBarImageColor3 = Color3.new(0, 0, 0)\n},\n\nTextLabel = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0,\n\n    Font = \"SourceSans\",\n    Text = \"\",\n    TextColor3 = Color3.new(0, 0, 0),\n    TextSize = 14\n},\n\nTextButton = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0,\n\n    AutoButtonColor = false,\n\n    Font = \"SourceSans\",\n    Text = \"\",\n    TextColor3 = Color3.new(0, 0, 0),\n    TextSize = 14\n},\n\nTextBox = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0,\n\n    ClearTextOnFocus = false,\n\n    Font = \"SourceSans\",\n    Text = \"\",\n    TextColor3 = Color3.new(0, 0, 0),\n    TextSize = 14\n},\n\nImageLabel = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0\n},\n\nImageButton = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0,\n\n    AutoButtonColor = false\n},\n\nViewportFrame = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0\n},\n\nVideoFrame = {\n    BackgroundColor3 = Color3.new(1, 1, 1),\n    BorderColor3 = Color3.new(0, 0, 0),\n    BorderSizePixel = 0\n}\n</code></pre>"},{"location":"api-reference/api/onchange/","title":"OnChange","text":"<pre><code>function OnChange(propertyName: string): Symbol\n</code></pre> <p>Generates symbols used to denote property change handlers when working with the New function.</p> <p>When using this symbol as a key in <code>New</code>'s property table, the value is expected to be a callback function. The callback will be connected to the property's <code>GetPropertyChangedSignal</code> event on the instance.</p> <p>Unlike normal property change handlers, the new value is passed in as an argument to the callback for convenience.</p> <p>Using OnChange with bound state</p> <p>When passing a state object or computed object as a property, changes in the state will only affect the property on the next render step (a concept known as 'deferred updating').</p> <p>Because <code>OnChange</code> connects to <code>GetPropertyChangedSignal</code>, it's possible to introduce subtle off-by-one-frame errors if you depend on <code>OnChange</code> to keep other things in sync with the property. Prefer to connect to the state's <code>onChange</code> event instead.</p>"},{"location":"api-reference/api/onchange/#parameters","title":"Parameters","text":"<ul> <li><code>propertyName: string</code> - the property to watch for changes on the instance</li> </ul>"},{"location":"api-reference/api/onchange/#example-usage","title":"Example Usage","text":"<pre><code>local example = New \"TextBox\" {\n    [OnChange \"Text\"] = function(newText)\n        print(\"You typed:\", newText)\n    end\n}\n</code></pre>"},{"location":"api-reference/api/onevent/","title":"OnEvent","text":"<pre><code>function OnEvent(eventName: string): Symbol\n</code></pre> <p>Generates symbols used to denote event handlers when working with the New function.</p> <p>When using this symbol as a key in <code>New</code>'s property table, the value is expected to be a callback function, which will be connected to the given event on the instance.</p> <p>The function acts as a normal event handler does; it receives all arguments from the event. The connection is automatically cleaned up when the instance is destroyed.</p>"},{"location":"api-reference/api/onevent/#parameters","title":"Parameters","text":"<ul> <li><code>eventName: string</code> - the name of the event on the instance</li> </ul>"},{"location":"api-reference/api/onevent/#example-usage","title":"Example Usage","text":"<pre><code>local example = New \"TextButton\" {\n    [OnEvent \"Activated\"] = function(...)\n        print(\"Activated event fired with args:\", ...)\n    end\n}\n</code></pre>"},{"location":"api-reference/api/spring/","title":"Spring","text":"<pre><code>function Spring(goalValue: State&lt;Animatable&gt;, speed: number?, dampingRatio: number?): Spring\n</code></pre> <p>Constructs and returns a new Spring state object, which follows the value of <code>goalValue</code>. The value of this object is simulated physically, as if linked to the goal value by a damped spring.</p> <p><code>speed</code> acts like a time multiplier; doubling <code>speed</code> corresponds to movement which is twice as fast.</p> <p><code>dampingRatio</code> affects the friction; <code>0</code> represents no friction, and <code>1</code> is just enough friction to reach the goal without overshooting or oscillating. This can be varied freely to fine-tune how much friction or 'bounce' your motion has.</p>"},{"location":"api-reference/api/spring/#parameters","title":"Parameters","text":"<ul> <li><code>goalValue: State&lt;Animatable&gt;</code> - the goal value this object should approach</li> <li><code>speed: number?</code> - how fast this object should approach the goal</li> <li><code>dampingRatio: number?</code> - scales how much friction is applied</li> </ul>"},{"location":"api-reference/api/spring/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/spring/#get","title":"<code>get()</code>","text":"<p><pre><code>function Spring:get(): any\n</code></pre> Returns the currently stored value of this Spring state object.</p> <p>If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.</p>"},{"location":"api-reference/api/spring/#example-usage","title":"Example Usage","text":"<pre><code>local position = State(UDim2.fromScale(0.25, 0.25))\n\nlocal ui = New \"Frame\" {\n    Position = Spring(position, 25, 0.5)\n}\n</code></pre> <pre><code>local playerCount = State(0)\nlocal smoothPlayerCount = Spring(playerCount)\n\nlocal message = Computed(function()\n    return \"Currently online: \" .. math.floor(smoothPlayerCount:get())\nend)\n</code></pre>"},{"location":"api-reference/api/state/","title":"State","text":"<pre><code>function State(initialValue: any?): State\n</code></pre> <p>Constructs and returns a new state object, with an optional initial value.</p>"},{"location":"api-reference/api/state/#parameters","title":"Parameters","text":"<ul> <li><code>initialValue: any?</code> - the value which should initially be stored in the state object.</li> </ul>"},{"location":"api-reference/api/state/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/state/#get","title":"<code>get()</code>","text":"<p><pre><code>function State:get(): any\n</code></pre> Returns the currently stored value of this state object.</p> <p>If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.</p>"},{"location":"api-reference/api/state/#set","title":"<code>set()</code>","text":"<p><pre><code>function State:set(newValue: any, force: boolean?)\n</code></pre> Sets the new value of this state object.</p> <p>If the new and old values differ, this will update any other objects using this state object. However, if they're the same, no update will be performed.</p> <p>Force updating</p> <p>If you want to override this behaviour, you can set <code>force</code> to <code>true</code>. This will ensure updates are always performed, even if the new and old values are the same (as measured by the == operator). This is most useful when working with mutable tables.</p> <p>However, be very careful with this, and only force updates when you need to for performance reasons. Try a solution involving immutable tables first. Abuse of force updating can lead to suboptimal code that updates redundantly.</p>"},{"location":"api-reference/api/state/#example-usage","title":"Example Usage","text":"<pre><code>local numCoins = State(50)\n\nprint(numCoins:get()) --&gt; 50\n\nnumCoins:set(25)\nprint(numCoins:get()) --&gt; 25\n\nnumCoins.onChange:Connect(function()\n    print(\"Coins changed to:\", numCoins:get())\nend)\n</code></pre>"},{"location":"api-reference/api/tween/","title":"Tween","text":"<pre><code>function Tween(goalValue: State&lt;Animatable&gt;, tweenInfo: TweenInfo?): Tween\n</code></pre> <p>Constructs and returns a new Tween state object, which follows the value of <code>goalValue</code>. When the goal value changes, the value of this object is tweened towards the goal value using the given <code>tweenInfo</code>.</p>"},{"location":"api-reference/api/tween/#parameters","title":"Parameters","text":"<ul> <li><code>goalValue: State&lt;Animatable&gt;</code> - the goal value this object should approach</li> <li><code>tweenInfo: TweenInfo?</code> - the tween to use when animating this object's value</li> </ul>"},{"location":"api-reference/api/tween/#object-methods","title":"Object Methods","text":""},{"location":"api-reference/api/tween/#get","title":"<code>get()</code>","text":"<p><pre><code>function Tween:get(): any\n</code></pre> Returns the currently stored value of this Tween state object.</p> <p>If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.</p>"},{"location":"api-reference/api/tween/#example-usage","title":"Example Usage","text":"<pre><code>local EASE = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)\n\nlocal position = State(UDim2.fromScale(0.25, 0.25))\nlocal ui = New \"Frame\" {\n    Position = Tween(position, EASE)\n}\n</code></pre> <pre><code>local playerCount = State(0)\nlocal smoothPlayerCount = Tween(playerCount)\n\nlocal message = Computed(function()\n    return \"Currently online: \" .. math.floor(smoothPlayerCount:get())\nend)\n</code></pre>"},{"location":"examples/","title":"Home","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> <p>Welcome to the Examples page! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting.</p>"},{"location":"examples/#fusion-obby","title":"Fusion Obby","text":"<p>See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti.</p> <p>Click here to view and edit the game on Roblox.</p>"},{"location":"extras/","title":"Extras","text":"<p>Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more!</p>"},{"location":"extras/#commonly-used","title":"Commonly Used","text":"<ul> <li>Backgrounds</li> <li>Brand Guidelines</li> </ul>"},{"location":"extras/backgrounds/","title":"Backgrounds","text":"<p>All backgrounds are PNG format, and have been optimised for these resolutions:</p> <ul> <li>Ultrawide (7680 x 1440)</li> <li>Widescreen (2560 x 1440)</li> <li>3:2 (2256 x 1504)</li> <li>Mobile (1125 x 2436)</li> </ul> <p>These backgrounds are intended for personal use only! These backgrounds are, and remain, the copyright of Elttob. You may not use these, commercially or otherwise, without explicit written consent.</p>"},{"location":"extras/backgrounds/#extrusion","title":"Extrusion","text":"<p>A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#construction","title":"Construction","text":"<p>The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#glow","title":"Glow","text":"<p>A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/backgrounds/#glow-alternate","title":"Glow (Alternate)","text":"<p>A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens.</p> <p></p> <ul> <li>Ultrawide</li> <li>Widescreen</li> <li>3:2</li> <li>Mobile</li> </ul>"},{"location":"extras/brand-guidelines/","title":"Brand Guidelines","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> <p>Fusion is a modern, lightweight library built to make UI development faster and accessible to more people.</p> <p>The Fusion brand is designed to reflect these themes.</p> <p>(TODO: add brand asset download link here)</p>"},{"location":"extras/brand-guidelines/#elements","title":"Elements","text":"<p>Stub</p> <p>This section is a stub - it may require more detail added to it in future.</p>"},{"location":"extras/brand-guidelines/#the-fusion-logo","title":"The Fusion logo","text":"<p>Our logo is constructed from two perpendicular intersecting planes, viewed from an almost-isometric angle. </p> <p>This represents how Fusion brings together two different data structures into one unified whole; Fusion connects the hierachy of instances to the hierachy of state objects.</p> <p>The logo is designed on an 8x8 pixel grid, making it highly legible and recognisable at almost any size.</p> <p>The colours chosen are energetic and warm, giving Fusion a uniquely hot colour palette compared to the cool blues of most other libraries and frameworks.</p> <p>It\u2019s a simple, abstract design, but stands out among many other Roblox libraries by not depending on the Roblox brand.</p>"},{"location":"extras/brand-guidelines/#using-fusion-brand-assets","title":"Using Fusion brand assets","text":"<p>Before using the Fusion logo or brand assets in your project, please be mindful of our policy around use of our branding. The rights to the Fusion name, logo and brand assets remain reserved by Elttob.</p> <p>We allow the following uses of the Fusion logo and branding by default:</p> <ul> <li>Representing the (original) Fusion project. <ul> <li>For example, you may use the the Fusion logo on-screen in a tutorial video when you're referring to the Fusion project...</li> <li>...as an image in a news article or blog post where you are talking about the Fusion project...</li> <li>...as an icon in a data visualisation to represent the Fusion project...</li> <li>...or in general, any use where it's very clear you're referring to the Fusion project. This does not extend to derived or inspired-by projects.</li> </ul> </li> </ul> <p>If you wish to use the Fusion logo, name or branding in your project for a use case which isn't listed above, you must receive explicit written permission from Elttob first.</p> <p>Please do not use the logo or branding in a way that:</p> <ul> <li>may insinuate support, endorsement or other affiliation with the Fusion project.<ul> <li>It's okay to say you were inspired by Fusion, or are using Fusion as part of your project...</li> <li>...but it's not okay if your project comes off as an official part of Fusion, or as something officially endorsed by the Fusion project.</li> </ul> </li> </ul>"},{"location":"tutorials/","title":"Get Started","text":"<p>Welcome to the Fusion tutorial section! Here, you'll learn how to build great interfaces with Fusion, even if you're a complete newcomer to the library.</p> <p>Early Beta</p> <p>Fusion is highly work-in-progress right now. There are a lot of features that don't work, aren't implemented, aren't documented fully or which may be tweaked or removed. We don't recommend using Fusion for any major project right now unless you're willing to take on the extra work of following these changes.</p> <p>More stable, long-term-supported Fusion versions will be available once Fusion exits beta testing.</p>"},{"location":"tutorials/#what-you-need-to-know","title":"What You Need To Know","text":"<p>These tutorials assume:</p> <ul> <li>You're comfortable with Roblox and the Luau scripting language.<ul> <li>These tutorials aren't an introduction to scripting! If you'd like to   learn, check out the Roblox DevHub.</li> </ul> </li> <li>You're familiar with how UI works on Roblox.<ul> <li>You don't have to be a designer - knowing about UI instances, events and data types like <code>UDim2</code> and <code>Color3</code> will be good enough.</li> </ul> </li> </ul> <p>Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged \ud83d\ude42</p>"},{"location":"tutorials/#how-these-tutorials-work","title":"How These Tutorials Work","text":"<p>You can find the tutorials in the navigation bar to your left. Tutorials are grouped together by category, and are designed to explore specific features of Fusion:</p> <ul> <li>'Fundamentals' introduces the core ideas of Fusion - making instances, storing state and responding to events.</li> <li>'Further Basics' builds on those core ideas by adding in useful utilities for building more complex UIs.</li> <li>'Animation' demonstrates how to add tweens, transitions and spring physics to bring your UI to life.</li> </ul> <p>You can either do them in order (recommended for newcomers), or you can jump to a specific tutorial for a quick refresh.</p> <p>You'll also see 'projects', which combine concepts from earlier tutorials and show how they interact and work together in a real setting.</p> <p>At the beginning of every tutorial, you'll see a section titled 'Required code'. They look like this - you can click to expand them:</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nprint(\"This is an example!\")\n</code></pre> <p>Before starting each tutorial, make sure to copy the code into your script editor, so you can follow along properly.</p> <p>Similarly, you'll find the finished code for the tutorial at the end, under 'Finished code':</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nprint(\"This is an example!\")\nprint(\"Pretend we added some code during the tutorial here...\")\n</code></pre> <p>You can use the finished code as a reference if you get stuck - it'll contain the script as it appears after following all the steps of the tutorial.</p>"},{"location":"tutorials/#installing-fusion","title":"Installing Fusion","text":"<p>Fusion is distributed as a single <code>ModuleScript</code>. Before starting, you'll need to add this module script to your game. Here's how:</p>"},{"location":"tutorials/#fusion-for-roblox-studio","title":"Fusion for Roblox Studio","text":"<p>If you script in Roblox Studio, here's how to install Fusion:</p> <p>Steps</p> <ol> <li>Head over to Fusion's 'Releases' page. There, you can find the latest version of Fusion.</li> <li>Under 'Assets', click the <code>.rbxm</code> file to download it. This contains the Fusion module script.</li> <li>In Roblox Studio, open or create a place.</li> <li>Right-click on ReplicatedStorage, and select 'Insert from File'.</li> <li>Find the <code>.rbxm</code> you just downloaded, and select it.</li> </ol> <p>You should now see a ModuleScript called 'Fusion' sitting in ReplicatedStorage - you're ready to go!</p>"},{"location":"tutorials/#fusion-for-external-editors","title":"Fusion for External Editors","text":"<p>If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, here's how to install Fusion:</p> Steps (click to expand) <ol> <li>Head over to Fusion's 'Releases' page. There, you can find the latest version of Fusion.</li> <li>Under 'Assets', click the <code>.zip</code> file to download it. Inside is a copy of the Fusion GitHub repository.</li> <li>Inside the zip, copy the <code>src</code> folder - it may be in a nested folder.</li> <li>Paste <code>src</code> into your local project, preferably in your <code>shared</code> folder if you have one.</li> <li>Rename the folder from <code>src</code> to <code>Fusion</code>.</li> </ol> <p>Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project.</p>"},{"location":"tutorials/#setting-up-a-test-script","title":"Setting Up A Test Script","text":"<p>Now that you've installed Fusion, you can set up a local script for testing. Here's how:</p> <ol> <li>Create a <code>LocalScript</code> in a service like <code>StarterGui</code> or <code>StarterPlayerScripts</code>.</li> <li>Remove the default code, and paste the following code in:</li> </ol> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n</code></pre> <p>Note</p> <p>This code assumes you've installed Fusion into ReplicatedStorage. If you've installed Fusion elsewhere, you'll need to tweak the <code>require()</code> to point to the correct location.</p> <p>If everything was set up correctly, you can press 'Play' and everything should run without any errors.</p> My script doesn't work - common errors <pre><code>Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\"\n</code></pre> <p>If you're seeing this error, then your script can't find Fusion. Refer back to the previous section and double-check you've set everything up properly.</p> <p>If you're using the installation guide from above, your <code>ReplicatedStorage</code> should look like this:</p> <p></p>"},{"location":"tutorials/#where-to-get-help","title":"Where To Get Help","text":"<p>Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion!</p> <p>Whatever you're looking for, here are some resources for you to get help:</p> <ul> <li>The Roblox OSS Discord has a #fusion channel</li> <li>Check out our Discussions page on GitHub</li> <li>Open an issue if you run into bugs or have feature requests</li> </ul>"},{"location":"tutorials/animation/project-3/","title":"Project 3: Switches","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/animation/springs/","title":"Springs","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/animation/tweens/","title":"Tweens","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/fundamentals/changing-children/","title":"Changing Children","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/fundamentals/changing-children/#passing-state-to-children","title":"Passing State To Children","text":"<p>Stub</p> <p>This section is a stub - it may require more detail added to it in future.</p> <p>Previously, we found that we could pass state objects as properties to bind them:</p> <pre><code>local message = State(\"Hello\")\n\nlocal gui = New \"TextLabel\" {\n    Text = message\n}\n\nmessage:set(\"World\") -- sets Text to World\n</code></pre> <p>The same principle works for <code>[Children]</code> - you can pass in a state object containing any children you'd like to add, and they'll be bound similarly:</p> <pre><code>local child = State(New \"Folder\" {})\n\nlocal gui = New \"TextLabel\" {\n    [Children] = child\n}\n\nchild:set(New \"ScreenGui\") -- changes the child from the folder to the screen gui\n</code></pre> <pre><code>local child1 = New \"Folder\" {}\nlocal child2 = New \"Folder\" {}\nlocal child3 = New \"Folder\" {}\n\nlocal children = State({child1, child2})\n\nlocal gui = New \"TextLabel\" {\n    [Children] = children\n}\n\nchildren:set({child2, child3}) -- unparents child1, parents child2\n</code></pre> <p>Note that when a child is removed like this, it is only unparented, not destroyed. Make sure to destroy any instances you remove if you're not using a helper like ComputedPairs.</p>"},{"location":"tutorials/fundamentals/changing-children/#deferred-updates","title":"Deferred Updates","text":"<p>Stub</p> <p>This section is a stub - it may require more detail added to it in future.</p> <p>Changes to bound children are deferred until the next render step, just like changes to bound properties.</p>"},{"location":"tutorials/fundamentals/changing-properties/","title":"Changing Properties","text":"<p>Now that we know how to represent and work with UI state, let's learn how to link up properties to our UI state so we can display a message on-screen.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n\nlocal numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" online.\"\nend)\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"ExampleGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = New \"TextLabel\" {\n        Position = UDim2.fromScale(.5, .5),\n        AnchorPoint = Vector2.new(.5, .5),\n        Size = UDim2.fromOffset(200, 50)\n    }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/changing-properties/#passing-state-to-properties","title":"Passing State To Properties","text":"<p>In our current code, we're using state and computed objects to store and process some data:</p> <pre><code>local numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" online.\"\nend)\n</code></pre> <p>When we use the <code>New</code> function, we can use these state objects as properties. In other words, we can set the Text of our label to be our <code>message</code> state:</p> <pre><code>local numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" online.\"\nend)\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"ExampleGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = New \"TextLabel\" {\n        Position = UDim2.fromScale(.5, .5),\n        AnchorPoint = Vector2.new(.5, .5),\n        Size = UDim2.fromOffset(200, 50),\n\nText = message\n}\n}\n</code></pre> <p>This will set the Text to whatever's stored in <code>message</code>, and keeps it updated as <code>message</code> is changed.</p> <p>To keep things neat and tidy, you can create the computed object directly next to the property instead, to keep it close to where it's used:</p> <pre><code>local numPlayers = State(5)\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"ExampleGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = New \"TextLabel\" {\n        Position = UDim2.fromScale(.5, .5),\n        AnchorPoint = Vector2.new(.5, .5),\n        Size = UDim2.fromOffset(200, 50),\n\nText = Computed(function()\nreturn \"There are \" .. numPlayers:get() .. \" online.\"\nend)\n}\n}\n</code></pre> <p>That's all you need to know - it's trivial to use any state as a property when using the <code>New</code> function.</p>"},{"location":"tutorials/fundamentals/changing-properties/#deferred-updates","title":"Deferred Updates","text":"<p>It's worth noting that property changes aren't applied right away - they're deferred until the next render step.</p> <p>In this example, the value of the state object is changed many times. However, Fusion will only update the property at the next render step, meaning we only see the last change have an effect:</p> Lua <pre><code>local state = State(1)\n\nlocal ins = New \"NumberValue\" {\n    Value = state,\n    [OnChange \"Value\"] = function(newValue)\n        print(\"Value is now:\", newValue)\n    end)\n}\n\nstate:set(2)\nstate:set(3)\nstate:set(4)\nstate:set(5)\n</code></pre> Expected output <pre><code>Value is now: 5\n</code></pre> <p>This is done for optimisation purposes; while it's relatively cheap to update state objects many times per frame, it's expensive to update instances. Furthermore, there's no reason to update an instance many times per frame, since it'll only be rendered once.</p> <p>In almost all cases, this is a desirable optimisation. However, in a select few cases, it can be problematic.</p> <p>Specifically, in the above example, the <code>OnChange</code> handler is not fired every time the state object changes value. Instead, it's fired in the render step after the state object is changed, because that's when the property actually changes.</p> <p>This can lead to subtle off-by-one-frame errors if you're not careful, so be cautious about using <code>OnChange</code> on properties you also bind state to.</p> <p>That's everything you need to know about connecting properties with state - it's a simple concept, but fundamental to creating dynamic and interactive UIs.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n\nlocal numPlayers = State(5)\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"ExampleGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = New \"TextLabel\" {\n        Position = UDim2.fromScale(.5, .5),\n        AnchorPoint = Vector2.new(.5, .5),\n        Size = UDim2.fromOffset(200, 50),\n\n        Text = Computed(function()\n            return \"There are \" .. numPlayers:get() .. \" online.\"\n        end)\n    }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/computations/","title":"Computations","text":"<p>Usually, we don't use state as-is in our UI; we normally process it first. Let's learn how to perform computations on our state.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n\nlocal numPlayers = State(5)\n</code></pre>"},{"location":"tutorials/fundamentals/computations/#the-computation-problem","title":"The Computation Problem","text":"<p>In UI development, lots of values are computed based on other values. For example, you might compute a message based on the number of players online:</p> <pre><code>local numPlayers = 5\nlocal message = \"There are \" .. numPlayers .. \" players online.\"\n</code></pre> <p>However, there's a problem - when <code>numPlayers</code> changes, we have to manually re-calculate the <code>message</code> value ourselves. If you don't, then the message will show the wrong amount of players - an issue known as 'data desynchronisation'.</p>"},{"location":"tutorials/fundamentals/computations/#computed-objects","title":"Computed Objects","text":"<p>To solve this problem, Fusion introduces a second kind of object - 'computed objects'. Instead of storing a fixed value, they run a computation. Think of it like a spreadsheet, where you can type in an equation that uses other values.</p> <p>To use computed objects, we first need to import the <code>Computed</code> constructor:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n</code></pre> <p>Now, we can create a computed object by calling the constructor. We pass in our computation as a function:</p> <pre><code>local numPlayers = State(5)\nlocal message = Computed(function()\nreturn \"There are \" .. numPlayers:get() .. \" players online.\"\nend)\n</code></pre> <p>At any time, you can get the computed value with the <code>:get()</code> method:</p> Lua <pre><code>local numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" players online.\"\nend)\n\nprint(message:get())\n</code></pre> Expected output <pre><code>There are 5 players online.\n</code></pre> <p>Now for the magic - whenever you use a state object as part of your computation, the computed object will update when the state object changes:</p> Lua <pre><code>local numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" players online.\"\nend)\n\nprint(message:get())\n\nnumPlayers:set(12)\nprint(message:get())\n</code></pre> Expected output <pre><code>There are 5 players online.\nThere are 12 players online.\n</code></pre> <p>This solves our previous 'data desynchronisation' issue - we don't have to manually recalculate the message. Instead, Fusion handles it for us, because we're storing our state in Fusion's objects.</p> <p>That's the basic idea of computed objects; they let you naturally define values in terms of other values.</p> <p>Danger - Yielding</p> <p>Code inside of a computed callback should never yield. While Fusion does not currently throw an error for this, there are plans to change this.</p> <p>Yielding in a callback may break a lot of Fusion code which depends on updates to your variables being instant, for example dependency management. It can also lead to internally inconsistent code.</p> <p>If you need to perform a web call when some state changes, consider using <code>Compat(state):onChange()</code> to bind a change listener, which is allowed to yield, and store the result of the web call in a state object for use elsewhere:</p> <pre><code>local playerID = State(1670764)\n\n-- bad - this will break!\nlocal playerData = Computed(function()\n    return ReplicatedStorage.GetPlayerData:InvokeServer(playerID:get())\nend)\n\n-- better - this moves the yielding safely outside of any state objects\n-- make sure to load the data for the first time if that's important\nlocal playerData = State(nil)\nCompat(playerData):onChange(function()\n    playerData:set(ReplicatedStorage.GetPlayerData:InvokeServer(playerID:get()))\nend)\n</code></pre> <p>In the future, there are plans to make yielding code easier to work with. See this issue for more details.</p> <p>Danger - Using non-state objects</p> <p>Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes.</p> <p>Fusion can't automatically detect changes when you use 'normal' variables:</p> <pre><code>local theVariable = \"Hello\"\nlocal badValue = Computed(function()\n    -- don't do this! use state objects or computed objects in here\n    return \"Say \" .. theVariable\nend)\n\nprint(badValue:get()) -- prints 'Say Hello'\n\ntheVariable = \"World\"\nprint(badValue:get()) -- still prints 'Say Hello' - that's a problem!\n</code></pre> <p>By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object:</p> <pre><code>local theVariable = State(\"Hello\")\nlocal goodValue = Computed(function()\n    -- this is much better - Fusion can detect we used this state object!\n    return \"Say \" .. theVariable:get()\nend)\n\nprint(goodValue:get()) -- prints 'Say Hello'\n\ntheVariable:set(\"World\")\nprint(goodValue:get()) -- prints 'Say World'\n</code></pre> <p>This also applies to any functions that change on their own, like <code>os.clock()</code>. If you need to use them, store values from the function in a state object, and update the value of that object as often as required.</p> <p>Now, we've covered everything we need to know about Fusion's basic state tools. Using computed objects and state objects together, you can easily store and compute values while avoiding data desynchronisation bugs.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n\nlocal numPlayers = State(5)\nlocal message = Computed(function()\n    return \"There are \" .. numPlayers:get() .. \" players online.\"\nend)\n\nprint(message:get())\n\nnumPlayers:set(12)\nprint(message:get())\n</code></pre>"},{"location":"tutorials/fundamentals/creating-ui/","title":"Creating UI","text":"<p>Now that we have Fusion up and running, let's learn how to create instances from a script quickly and neatly.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n</code></pre>"},{"location":"tutorials/fundamentals/creating-ui/#instances-from-code","title":"Instances from Code","text":"<p>In Fusion, you create all of your UI instances from code. That might sound counterproductive, but it will soon allow you to easily reuse your UI components and leverage powerful tools for connecting your UI and game scripts together.</p> <p>To make the experience more pleasant, Fusion introduces an alternative to <code>Instance.new</code> which lets you construct entire instances in one go - called the <code>New</code> function.</p> <p>Here's an example code snippet using <code>New</code> - you can compare it to <code>Instance.new</code>:</p> New <pre><code>local myPart = New \"Part\" {\n    Parent = workspace,\n\n    Position = Vector3.new(1, 2, 3),\n    BrickColor = BrickColor.new(\"Bright green\"),\n    Size = Vector3.new(2, 1, 4)\n}\n</code></pre> Instance.new <pre><code>local myPart = Instance.new(\"Part\")\n\nmyPart.Position = Vector3.new(1, 2, 3)\nmyPart.BrickColor = BrickColor.new(\"Bright green\")\nmyPart.Size = Vector3.new(2, 1, 4)\n\nmyPart.Parent = workspace\n</code></pre> <p>Note</p> <p>You don't need parentheses <code>()</code> for <code>New</code> - just type the class name and properties like we did above.</p> <p>In the above code snippet, the <code>New</code> function:</p> <ul> <li>creates a new part</li> <li>gives it a position, size and colour</li> <li>parents it to the workspace</li> <li>returns the part, so it can be stored in <code>myPart</code></li> </ul> <p>The <code>New</code> function has many more features built in, which you'll use later, but for now we'll just use it to set properties.</p>"},{"location":"tutorials/fundamentals/creating-ui/#making-a-screengui","title":"Making A ScreenGui","text":"<p>Let's use the <code>New</code> function to create a ScreenGui.</p> <p>We're going to put it in our PlayerGui, so we need to import the <code>Players</code> service:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n</code></pre> <p>We'll also need to import <code>New</code> from Fusion:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\n</code></pre> <p>Now, we can use the <code>New</code> function like we did in the snippet above. We want to create a ScreenGui with a name of 'MyFirstGui' parented to our PlayerGui.</p> <p>The following code snippet does all of this for us:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\n\nlocal gui = New \"ScreenGui\" {\nParent = Players.LocalPlayer.PlayerGui,\nName = \"MyFirstGui\"\n}\n</code></pre> <p>If you press 'Play', you should see that a ScreenGui has appeared in your PlayerGui, with all of the properties we've set:</p> <p></p> <p>Hopefully you're getting comfortable with this syntax - we'll expand on it in the next section.</p> Tip <p>Fusion automatically applies some 'sensible default' properties for you, so you don't have to specify them. Here, <code>ZIndexBehavior</code> will default to 'false' and <code>ResetOnSpawn</code> defaults to <code>false</code>. You can see a list of all default properties here.</p>"},{"location":"tutorials/fundamentals/creating-ui/#adding-a-child","title":"Adding a Child","text":"<p>Let's now add a TextLabel with a message and parent it to our ScreenGui.</p> <p>To help with this, the <code>New</code> function lets us add children directly to our instance. In order to use this feature, we first need to import <code>Children</code> from Fusion:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\n</code></pre> <p>Now, we can make any instance a child of our ScreenGui - just pass it in using <code>[Children]</code> as the key.</p> <p>For example, here we're creating our TextLabel, and adding it as a child:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n[Children] = New \"TextLabel\" {\nPosition = UDim2.fromScale(.5, .5),\nAnchorPoint = Vector2.new(.5, .5),\nSize = UDim2.fromOffset(200, 50),\nText = \"Fusion is fun :)\"\n}\n}\n</code></pre> <p>If you press 'Play' now, you should see a TextLabel in the centre of your screen:</p> <p></p>"},{"location":"tutorials/fundamentals/creating-ui/#multiple-children","title":"Multiple Children","text":"<p>You can add more than one instance - <code>Children</code> supports arrays of instances.</p> <p>If we wanted multiple TextLabels, we can create an array to hold our children:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n[Children] = {\nNew \"TextLabel\" {\n            Position = UDim2.fromScale(.5, .5),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Fusion is fun :)\"\n        }\n}\n}\n</code></pre> <p>Now, we can add another TextLabel to the array, and it will also be parented:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"TextLabel\" {\n            Position = UDim2.fromScale(.5, .5),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Fusion is fun :)\"\n        },\n\nNew \"TextLabel\" {\nPosition = UDim2.new(.5, 0, .5, 50),\nAnchorPoint = Vector2.new(.5, .5),\nSize = UDim2.fromOffset(200, 50),\nText = \"Two is better than one!\"\n}\n}\n}\n</code></pre> <p>If you press 'Play', you should see both TextLabels appear:</p> <p></p> <p>Congratulations - you've now learned how to create simple instances with Fusion! Over the course of the next few tutorials, you'll see this syntax being used a lot, so you'll have some time to get used to it.</p> <p>It's important to understand the basics of the <code>New</code> function, as it's used throughout almost all Fusion code.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"TextLabel\" {\n            Position = UDim2.fromScale(.5, .5),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Fusion is fun :)\"\n        },\n\n        New \"TextLabel\" {\n            Position = UDim2.new(.5, 0, .5, 50),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Two is better than one!\"\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/handling-events/","title":"Handling Events","text":"<p>Now that we can create instances, let's learn how to handle events and property changes.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"TextButton\" {\n            Position = UDim2.new(0.5, 0, 0.5, -100),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Click me!\"\n        },\n\n        New \"TextBox\" {\n            Position = UDim2.new(0.5, 0, 0.5, 100),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"\",\n            ClearTextOnFocus = false\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/handling-events/#connecting-to-events","title":"Connecting to Events","text":"<p>Inside the code from above, you'll notice a TextButton. Let's try to connect to it's <code>Activated</code> event to detect mouse clicks.</p> <p>To help with this, <code>New</code> allows us to add event handlers on our instance directly. In order to use this feature, we need to import <code>OnEvent</code> from Fusion:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\nlocal OnEvent = Fusion.OnEvent\n</code></pre> <p>Now you can pass in event handling functions by using <code>[OnEvent \"EventName\"]</code> as the key.</p> <p>As an example, here we're connecting a function to our TextButton's <code>Activated</code> event:</p> <pre><code>    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"TextButton\" {\n            Position = UDim2.fromScale(.5, .5),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Fusion is fun :)\",\n\n[OnEvent \"Activated\"] = function(...)\nprint(\"Clicked!\", ...)\nend\n},\n\n        New \"TextBox\" {\n            Position = UDim2.new(0.5, 0, 0.5, 100),\n</code></pre> <p>This works just like a regular <code>:Connect()</code> - you'll recieve all the arguments from the event. Here, we're just printing them out for demonstration purposes.</p> <p>If you press 'Play' and click the button a few times, you should see something like this in the output:</p> <p></p> <p>That's all there is to event handling! Fusion will manage the event connections for you automatically.</p>"},{"location":"tutorials/fundamentals/handling-events/#responding-to-change","title":"Responding to Change","text":"<p>In addition to regular events, you can listen to property change events (the events returned by <code>GetPropertyChangedSignal</code>).</p> <p>In order to use property change events, you'll need to import <code>OnChange</code>:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\nlocal OnEvent = Fusion.OnEvent\nlocal OnChange = Fusion.OnChange\n</code></pre> <p>Now you can pass in functions using <code>[OnChange \"PropertyName\"]</code> as the key. When the property is changed, your function will be called with the new value as the only argument.</p> <p>To demonstrate this, here we're printing the text in our TextBox whenever it changes:</p> <pre><code>            [OnEvent \"Activated\"] = function(...)\n                print(\"Clicked!\", ...)\n            end\n        },\n\n        New \"TextBox\" {\n            Position = UDim2.new(0.5, 0, 0.5, 100),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"\",\n            ClearTextOnFocus = false,\n\n[OnChange \"Text\"] = function(newText)\nprint(newText)\nend\n}\n    }\n}\n</code></pre> <p>Now, if you press 'Play' and start typing into the TextBox, you should see the TextBox's contents being printed to the output for each character you type:</p> <p></p> <p>With that, you've covered everything there is to know about event and property change handlers! In later tutorials, this will be useful for responding to user input.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\nlocal OnEvent = Fusion.OnEvent\nlocal OnChange = Fusion.OnChange\n\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"MyFirstGui\",\n    ResetOnSpawn = false,\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"TextButton\" {\n            Position = UDim2.new(0.5, 0, 0.5, -100),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"Click me!\",\n\n            [OnEvent \"Activated\"] = function(...)\n                print(\"Clicked!\", ...)\n            end\n        },\n\n        New \"TextBox\" {\n            Position = UDim2.new(0.5, 0, 0.5, 100),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Text = \"\",\n            ClearTextOnFocus = false,\n\n            [OnChange \"Text\"] = function(newText)\n                print(newText)\n            end\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/fundamentals/project-1/","title":"Project 1: Counting Clicks","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p> <p>Using everything we've learned so far, let's build a complete UI to see how Fusion's basic tools work together in a real project.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\nlocal OnEvent = Fusion.OnEvent\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n</code></pre>"},{"location":"tutorials/fundamentals/project-1/#building-the-ui","title":"Building The UI","text":"<p>We'll be creating a button which shows how many times you've clicked it - this is often used as an introductory UI example for many libraries and frameworks because it involves UI, event handling and state management together.</p> <p>We'll start by creating a ScreenGui to contain our button:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal New = Fusion.New\nlocal Children = Fusion.Children\nlocal OnEvent = Fusion.OnEvent\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n\nlocal gui = New \"ScreenGui\" {\nParent = Players.LocalPlayer.PlayerGui,\nName = \"CountingGui\",\nZIndexBehavior = \"Sibling\"\n}\n</code></pre> <p>Next, we'll create a TextButton we can click, and a message TextLabel which will eventually show how many clicks we've performed:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"CountingGui\",\n    ZIndexBehavior = \"Sibling\",\n\n[Children] = {\nNew \"TextButton\" {\nName = \"ClickButton\",\nPosition = UDim2.fromScale(.5, .5),\nSize = UDim2.fromOffset(200, 50),\nAnchorPoint = Vector2.new(.5, .5),\nBackgroundColor3 = Color3.fromRGB(85, 255, 0),\nText = \"Click me!\"\n},\nNew \"TextLabel\" {\nName = \"Message\",\nPosition = UDim2.new(0.5, 0, 0.5, 100),\nSize = UDim2.fromOffset(200, 50),\nAnchorPoint = Vector2.new(.5, .5),\nBackgroundColor3 = Color3.fromRGB(255, 255, 255),\nText = \"Placeholder message...\"\n}\n}\n}\n</code></pre> <p>With just these three instances, we have enough to work with for the rest of this tutorial. Running the above script gives us this:</p> <p></p>"},{"location":"tutorials/fundamentals/project-1/#adding-state","title":"Adding State","text":"<p>Now, let's add some state to make our UI dynamic. Let's start with a state object to store the number of clicks:</p> <pre><code>local numClicks = State(0)\nlocal gui = New \"ScreenGui\" {\n    Parent = Players.LocalPlayer.PlayerGui,\n\n    Name = \"CountingGui\",\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n</code></pre> <p>Now, we can replace the placeholder text with some computed state, to turn our number of clicks into a fully-formed message:</p> <pre><code>            Text = \"Click me!\"\n        },\n\n        New \"TextLabel\" {\n            Name = \"Message\",\n            Position = UDim2.new(0.5, 0, 0.5, 100),\n            Size = UDim2.fromOffset(200, 50),\n            AnchorPoint = Vector2.new(.5, .5),\n\n            BackgroundColor3 = Color3.fromRGB(255, 255, 255),\n\nText = Computed(function()\nreturn \"You clicked \" .. numClicks:get() .. \" times.\"\nend)\n}\n    }\n}\n</code></pre> <p>You'll now notice the message's text reflects the number of clicks stored in <code>numClicks</code>:</p> <p></p>"},{"location":"tutorials/fundamentals/project-1/#listening-for-clicks","title":"Listening for Clicks","text":"<p>Now that we have our UI in place and it's working with our state, we just need to increment the number stored in <code>numClicks</code> when we click the button.</p> <p>To start, let's add an <code>OnEvent</code> handler for the button's Activated event. This will run when we click the button:</p> <pre><code>    [Children] = {\n        New \"TextButton\" {\n            Name = \"ClickButton\",\n            Position = UDim2.fromScale(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n            AnchorPoint = Vector2.new(.5, .5),\n\n            BackgroundColor3 = Color3.fromRGB(85, 255, 0),\n\n            Text = \"Click me!\",\n\n[OnEvent \"Activated\"] = function()\n-- the button was clicked!\n-- TODO: increment state\nend\n},\n\n        New \"TextLabel\" {\n</code></pre> <p>Then, to increment the state, we can <code>:get()</code> the number of clicks, add one, then <code>:set()</code> it to the new value:</p> <pre><code>    [Children] = {\n        New \"TextButton\" {\n            Name = \"ClickButton\",\n            Position = UDim2.fromScale(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n            AnchorPoint = Vector2.new(.5, .5),\n\n            BackgroundColor3 = Color3.fromRGB(85, 255, 0),\n\n            Text = \"Click me!\",\n\n            [OnEvent \"Activated\"] = function()\n                -- the button was clicked!\nnumClicks:set(numClicks:get() + 1)\nend\n        },\n\n        New \"TextLabel\" {\n</code></pre> <p>That's everything - try clicking the button, and watch the message change in response:</p> <p></p> <p>If you've managed to follow along, congratulations - you should now have a good understanding of Fusion's fundamental concepts!</p> <p>With just these tools alone, you'll be able to build almost anything you can think of. However, Fusion still has more tools available to make your code simpler and easier to manage - we'll cover this in 'Further Basics'.</p>"},{"location":"tutorials/fundamentals/storing-state/","title":"Storing State","text":"<p>Our UIs may use some data - called 'state' - to change how it appears. Let's learn how to store this data in Fusion.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n</code></pre>"},{"location":"tutorials/fundamentals/storing-state/#what-is-state","title":"What is State?","text":"<p>State is (simplistically) the variables that determine what your UI looks like at a given point in time.</p> <p>A simple example of this is a health bar. To know what the health bar looks like at any point in time, we need to know two things:</p> <ul> <li>the current health to show</li> <li>the max health of the player</li> </ul> <p>These two variables are therefore known as the 'state' of the health bar. To show the health bar on the screen, we need to use the values of these variables.</p>"},{"location":"tutorials/fundamentals/storing-state/#storing-state","title":"Storing State","text":"<p>Fusion provides some nice tools for manipulating state and using it in our UI, but in order to use those tools, we need to store our state in 'state objects' - simple OOP objects that store a single value.</p> <p>To use state objects, we first need to import the <code>State</code> constructor:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n</code></pre> <p>Now, we can create a state object by calling the constructor. If you pass in a value, it'll be stored inside the state object:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n\nlocal message = State(\"Hello\")\n</code></pre> <p>At any time, you can get the currently stored value with the <code>:get()</code> method:</p> Lua <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n\nlocal message = State(\"Hello\")\nprint(\"The value is:\", message:get())\n</code></pre> Expected output <pre><code>The value is: Hello\n</code></pre> <p>You can also set the value by calling <code>:set()</code> with a new value:</p> Lua <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n\nlocal message = State(\"Hello\")\nprint(\"The value is:\", message:get())\n\nmessage:set(\"World\")\nprint(\"The new value is:\", message:get())\n</code></pre> Expected output <pre><code>The value is: Hello\nThe new value is: World\n</code></pre> <p>With that, you should have the basic idea of state objects - they're kind of like variables, but in object form. These objects will later act like 'inputs' into Fusion's other state management tools.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\n\nlocal message = State(\"Hello\")\nprint(\"The value is:\", message:get())\n\nmessage:set(\"World\")\nprint(\"The new value is:\", message:get())\n</code></pre>"},{"location":"tutorials/further-basics/arrays-and-lists/","title":"Arrays and Lists","text":"<p>Efficiently working with tables can be difficult. Let's learn about the tools Fusion provides to make working with arrays and tables easier.</p> Required code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\n\nlocal numbers = State({1, 2, 3, 4, 5})\n</code></pre>"},{"location":"tutorials/further-basics/arrays-and-lists/#computed-arrays","title":"Computed Arrays","text":"<p>Suppose we have a state object storing an array of numbers, and we'd like to create a computed object which doubles each number. You could achieve this with a for-pairs loop:</p> <pre><code>local numbers = State({1, 2, 3, 4, 5})\n\nlocal doubledNumbers = Computed(function()\nlocal doubled = {}\nfor index, number in pairs(numbers:get()) do\ndoubled[index] = number * 2\nend\nreturn doubled\nend)\nprint(doubledNumbers:get()) --&gt; {2, 4, 6, 8, 10}\n</code></pre> <p>While this works, it's pretty verbose. To make this code simpler, Fusion has a special computed object designed for processing tables, known as <code>ComputedPairs</code>.</p> <p>To use it, we need to import <code>ComputedPairs</code> from Fusion:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\nlocal ComputedPairs = Fusion.ComputedPairs\n</code></pre> <p><code>ComputedPairs</code> acts similarly to the for-pairs loop we wrote above - it goes through each entry of the array, processes the value, and saves it into the new array:</p> <pre><code>local numbers = State({1, 2, 3, 4, 5})\n\nlocal doubledNumbers = ComputedPairs(numbers, function(index, number)\nreturn number *  2\nend)\nprint(doubledNumbers:get()) --&gt; {2, 4, 6, 8, 10}\n</code></pre> <p>This can be used to process any kind of table, not just arrays. Notice how the keys stay the same, and the value is whatever you return:</p> <pre><code>local data = State({Blue = \"good\", Green = \"bad\"})\n\nlocal processedData = ComputedPairs(data, function(colour, word)\n    return colour .. \" is \" .. word\nend)\n\nprint(processedData:get()) --&gt; {Blue = \"Blue is good\", Green = \"Green is bad\"}\n</code></pre>"},{"location":"tutorials/further-basics/arrays-and-lists/#cleaning-up-values","title":"Cleaning Up Values","text":"<p>Sometimes, you might use <code>ComputedPairs</code> to generate lists of instances, or other similar data types. When we're done with these, we need to destroy them.</p> <p>Conveniently, <code>ComputedPairs</code> already cleans up some types when they're removed from the output array:</p> <ul> <li>returned instances will be destroyed</li> <li>returned event connections will be disconnected</li> <li>returned functions will be run</li> <li>returned objects will have their <code>:Destroy()</code> or <code>:destroy()</code> methods called</li> <li>returned arrays will have their contents cleaned up</li> </ul> <p>This should cover most use cases by default. However, if you need to override this cleanup behaviour, you can pass in an optional <code>destructor</code> function as the second argument. It will be called any time a generated value is removed or overwritten, so you can clean it up:</p> Lua <pre><code>local names = State({\"John\", \"Dave\", \"Sebastian\"})\n\nlocal greetings = ComputedPairs(\n    names,\n    function(index, name)\n        return \"Hello, \" .. name\n    end,\nfunction(greeting)\nprint(\"Removed: \" .. greeting)\nend\n)\n\nnames:set({\"John\", \"Trey\", \"Charlie\"})\n</code></pre> Expected output <pre><code>Removed: Hello, Dave\nRemoved: Hello, Sebastian\n</code></pre>"},{"location":"tutorials/further-basics/arrays-and-lists/#optimisation","title":"Optimisation","text":"<p>To improve performance, <code>ComputedPairs</code> doesn't recalculate a key if its value stays the same:</p> Lua <pre><code>local data = State({\n    One = 1,\n    Two = 2,\n    Three = 3\n})\n\nprint(\"Creating processedData...\")\n\nlocal processedData = ComputedPairs(data, function(key, value)\n    print(\"  ...recalculating key: \" .. key)\n    return value * 2\nend)\n\nprint(\"Changing the values of some keys...\")\ndata:set({\n    One = 1,\n    Two = 100,\n    Three = 3,\n    Four = 4\n})\n</code></pre> Expected output <pre><code>Creating processedData...\n  ...recalculating key: One\n  ...recalculating key: Two\n  ...recalculating key: Three\nChanging the values of some keys...\n  ...recalculating key: Two\n  ...recalculating key: Four\n</code></pre> <p>Because the keys <code>Two</code> and <code>Four</code> have different values after the change, they're recalculated. However, <code>One</code> and <code>Three</code> have the same values, so they'll be reused instead:</p> <p></p> <p>This is a simple rule which should work well for tables with 'stable keys' (keys that don't change as other values are added and removed).</p> <p>However, if you're working with 'unstable keys' (e.g. an array where values can move to different keys) then you can get unnecessary recalculations. In the following code, <code>Yellow</code> gets recalculated, because it moves to a different key:</p> Lua <pre><code>local data = State({\"Red\", \"Green\", \"Blue\", \"Yellow\"})\n\nprint(\"Creating processedData...\")\n\nlocal processedData = ComputedPairs(data, function(key, value)\n    print(\"  ...recalculating key: \" .. key .. \" value: \" .. value)\n    return value\nend)\n\nprint(\"Removing Blue...\")\ndata:set({\"Red\", \"Green\", \"Yellow\"})\n</code></pre> Expected output <pre><code>Creating processedData...\n  ...recalculating key: 1 value: Red\n  ...recalculating key: 2 value: Green\n  ...recalculating key: 3 value: Blue\n  ...recalculating key: 4 value: Yellow\nMoving the values around...\n  ...recalculating key: 3 value: Yellow\n</code></pre> <p>You can see this more clearly in the following diagram - the value of key 3 was changed, so it triggered a recalculation:</p> <p></p> <p>If the keys aren't needed, you can use your values as keys instead. This makes them stable, because they won't be affected by other insertions or removals:</p> Lua <pre><code>local data = State({Red = true, Green = true, Blue = true, Yellow = true})\nprint(\"Creating processedData...\")\n\nlocal processedData = ComputedPairs(data, function(key)\nprint(\"  ...recalculating key: \" .. key)\nreturn key\nend)\nprint(\"Removing Blue...\")\ndata:set({Red = true, Green = true, Yellow = true})\n</code></pre> Expected output <pre><code>Creating processedData...\n  ...recalculating key: Red\n  ...recalculating key: Green\n  ...recalculating key: Blue\n  ...recalculating key: Yellow\nRemoving Blue...\n</code></pre> <p>Notice that, when we remove <code>Blue</code>, no other values are recalculated. This is ideal, and means we're not doing unnecessary processing:</p> <p></p> <p>This is especially important when optimising 'heavy' arrays, for example long lists of instances. The less unnecessary recalculation, the better!</p> <p>With that, you should now have a basic idea of how to work with table state in Fusion. When you get used to this workflow, you can express your logic cleanly, and get great caching and cleanup behaviour for free.</p> Finished code <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Fusion = require(ReplicatedStorage.Fusion)\n\nlocal State = Fusion.State\nlocal Computed = Fusion.Computed\nlocal ComputedPairs = Fusion.ComputedPairs\n\nlocal data = State({Red = true, Green = true, Blue = true, Yellow = true})\n\nprint(\"Creating processedData...\")\n\nlocal processedData = ComputedPairs(data, function(key)\n    print(\"  ...recalculating key: \" .. key)\n    return key\nend)\n\nprint(\"Removing Blue...\")\ndata:set({Red = true, Green = true, Yellow = true})\n</code></pre>"},{"location":"tutorials/further-basics/compatibility/","title":"Compatibility","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"},{"location":"tutorials/further-basics/components/","title":"Components","text":"<p>It's often a good idea to split our UI into reusable parts, known as 'components'. Let's learn how you can create these with Fusion.</p>"},{"location":"tutorials/further-basics/components/#what-are-components","title":"What are Components?","text":"<p>When we think about UIs as humans, we typically think of them in terms of reusable 'blocks' of UI. For example, you may divide up the following interface into these 'blocks':</p> <p></p> <p>In UI design and development, these are widely known as 'components'.</p> <p>Components are useful, because we only need to define what each component looks like generally. We can then apply that look to every component across our UI. You can even provide properties, like some text to insert, or whether to show an icon:</p> <p></p> <p>Building our UI by assembling components (rather than creating every instance manually) will help us to reuse and organise our UI code, and makes it easier to read and edit.</p>"},{"location":"tutorials/further-basics/components/#reusing-ui","title":"Reusing UI","text":"<p>When we want to reuse a bit of code, we often put it in a function. We can then use that code snippet in multiple places, optionally providing arguments to tweak how it runs.</p> <p>This lines up with what we need 'components' to do - we want to be able to reuse parts of our UI in multiple places, optionally providing properties to tweak how it looks.</p> <p>That's why, in Fusion, components are just functions. They take in a table of properties, create some UI, and return it:</p> <pre><code>local function Greeting(props)\n    return New \"TextLabel\" {\n        BackgroundColor3 = Color3.new(1, 1, 0),\n        TextColor3 = Color3.new(0, 0, 1),\n        Size = UDim2.fromOffset(200, 50),\n        Text = props.Message\n    }\nend\n</code></pre> <p>We can now call the <code>Greeting</code> function to get a copy of that UI with any message we'd like:</p> <pre><code>local greeting1 = Greeting {\n    Message = \"Hello!\"\n}\n\nlocal greeting2 = Greeting {\n    Message = \"Hey :)\"\n}\n</code></pre> <p>Note</p> <p>If you're using a single <code>props</code> argument (like we did above), you don't need any parentheses <code>()</code> when you call the function with a table!</p> <p>We can also blend components into our other Fusion code easily:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Name = \"ExampleGui\",\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = Greeting {\n        Message = \"What's up? B)\"\n    }\n}\n</code></pre> <p>This makes components a powerful tool for creating tidy, reusable UI code inside Fusion.</p> <p>For the rest of this tutorial, let's look at a few common scripting patterns you can use with components to make them even more useful.</p>"},{"location":"tutorials/further-basics/components/#passing-in-children","title":"Passing in Children","text":"<p>Sometimes, we want to create components that can hold children. For example, take a look at this component, which arranges some children into a scrolling grid:</p> <pre><code>local function Gallery(props)\n    return New \"ScrollingFrame\" {\n        Position = props.Position,\n        Size = props.Size,\n        AnchorPoint = props.AnchorPoint,\n\n        [Children] = {\n            New \"UIGridLayout\" {\n                CellPadding = UDim2.fromOffset(4, 4),\n                CellSize = UDim2.fromOffset(100, 100)\n            },\n\n            -- TODO: put some children here?\n        }\n    }\nend\n</code></pre> <p>Suppose we'd like users to be able to pass in children to show up in the grid:</p> <pre><code>local gallery = Gallery {\n    Position = UDim2.fromScale(.5, .5)\n    Size = UDim2.fromOffset(400, 300),\n    AnchorPoint = Vector2.new(.5, .5),\n\n    [Children] = {\n        New \"ImageLabel\" { ... },\n        New \"ImageLabel\" { ... },\n        New \"ImageLabel\" { ... }\n    }\n}\n</code></pre> <p>We can access those children in our function using <code>props[Children]</code>. Since the <code>New</code> function lets us pass in arrays of children, we can just include it directly in our code like so:</p> <pre><code>local function Gallery(props)\n    return New \"ScrollingFrame\" {\n        Position = props.Position,\n        Size = props.Size,\n        AnchorPoint = props.AnchorPoint,\n\n        [Children] = {\n            New \"UIGridLayout\" {\n                CellPadding = UDim2.fromOffset(4, 4),\n                CellSize = UDim2.fromOffset(100, 100)\n            },\n\n            props[Children]\n        }\n    }\nend\n</code></pre> <p>That's all there is to it! Just keep in mind that <code>[Children]</code> is still a property like any other, so if you're processing the children, it might be good to do some type checking first.</p>"},{"location":"tutorials/further-basics/components/#multiple-instances","title":"Multiple Instances","text":"<p>In some specific circumstances, you may want to return more than one instance from a component.</p> <p>You shouldn't return multiple values from a component directly. Because of how Lua works, this can introduce subtle bugs in your code:</p> <pre><code>local function ManyThings(props)\n    -- don't do this!\n    -- you should only return one value from a component\n    return\n        New \"TextLabel\" {...},\n        New \"ImageButton\" {...},\n        New \"Frame\" {...}\nend\n\nlocal gui1 = New \"ScreenGui\" {\n    -- this will only parent the TextLabel!\n    [Children] = ManyThings {}\n}\n\nlocal gui2 = New \"ScreenGui\" {\n    [Children] = {\n        New \"TextLabel\" {...},\n\n        -- this is also broken\n        ManyThings {},\n\n        New \"TextLabel\" {...}\n    }\n}\n</code></pre> <p>A better way to do this is to return an array of instances. This means you only return a single value - the array. This gets around the subtle bugs that normally occur when dealing with multiple return values.</p> <p>Since <code>[Children]</code> supports arrays of children, all our instances are now parented as expected:</p> <pre><code>local function ManyThings(props)\n    -- using an array ensures we only return one value\n    return {\n        New \"TextLabel\" {...},\n        New \"ImageButton\" {...},\n        New \"Frame\" {...}\n    }\nend\n\nlocal gui1 = New \"ScreenGui\" {\n    -- this now works!\n    [Children] = ManyThings {}\n}\n\nlocal gui2 = New \"ScreenGui\" {\n    [Children] = {\n        New \"TextLabel\" {...},\n\n        -- this also now works!\n        ManyThings {},\n\n        New \"TextLabel\" {...}\n    }\n}\n</code></pre> <p>Tip</p> <p>If you're coming from other UI libraries or frameworks, you may have heard of this concept referred to as 'fragments'. In Fusion, fragments are just plain arrays of children rather than a special kind of object.</p>"},{"location":"tutorials/further-basics/components/#callbacks","title":"Callbacks","text":"<p>For some components (e.g. buttons or text boxes), some code might need to run in response to events like clicks or typing. You can use callbacks to achieve this.</p> <p>Consider this <code>Button</code> component as an example. Notice we're using <code>props.OnClick</code> with <code>[OnEvent \"Activated\"]</code>:</p> <pre><code>local function Button(props)\n    return New \"TextButton\" {\n        Position = props.Position,\n        AnchorPoint = props.AnchorPoint,\n        Size = props.Size,\n\n        BackgroundColor3 = Color3.new(0, 0.4, 1),\n        TextColor3 = Color3.new(1, 1, 1),\n        Text = props.Message,\n\n        [OnEvent \"Activated\"] = props.OnClick\n    }\nend\n</code></pre> <p>This means that anyone using the <code>Button</code> component can provide a callback function, which will then be run when the button is clicked:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Name = \"ExampleGui\",\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        Button {\n            Position = UDim2.fromScale(.5, .5),\n            AnchorPoint = Vector2.new(.5, .5),\n            Size = UDim2.fromOffset(200, 50),\n\n            Message = \"Click me!\",\n\n            OnClick = function()\n                -- this callback function will be passed into OnEvent, so it'll\n                -- run when the button is clicked\n                print(\"The button was clicked!\")\n            end\n        },\n    }\n}\n</code></pre> <p>This isn't just limited to event handlers, either - any time you want to let the caller provide some code, callbacks are a great option.</p>"},{"location":"tutorials/further-basics/components/#state","title":"State","text":"<p>Because components are functions, we can do more than just creating instances. You can also store state inside them!</p> <p>Let's make a 'toggle button' component to demonstrate this. When we click it, it should toggle on and off.</p> <p>Here's some basic code to get started - we just need to add some state to this:</p> <pre><code>local function ToggleButton(props)\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(1, 1, 1),\n        TextColor3 = Color3.new(0, 0, 0),\n        Size = UDim2.fromOffset(200, 50),\n        Text = props.message,\n\n        [OnEvent \"Activated\"] = function()\n            -- TODO: toggle the button!\n        end\n    }\nend\n</code></pre> <p>Firstly, let's create a state object to store whether the button is currently toggled on or off:</p> <pre><code>local function ToggleButton(props)\n    local isButtonOn = State(false)\n\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(1, 1, 1),\n        TextColor3 = Color3.new(0, 0, 0),\n        Text = props.message,\n\n        [OnEvent \"Activated\"] = function()\n            -- TODO: toggle the button!\n        end\n    }\nend\n</code></pre> <p>Next, we can toggle the stored value in our event handler:</p> <pre><code>local function ToggleButton(props)\n    local isButtonOn = State(false)\n\n    return New \"TextButton\" {\n        BackgroundColor3 = Color3.new(1, 1, 1),\n        TextColor3 = Color3.new(0, 0, 0),\n        Text = props.message,\n\n        [OnEvent \"Activated\"] = function()\n            isButtonOn:set(not isButtonOn:get())\n        end\n    }\nend\n</code></pre> <p>Finally, we can make the background colour show whether the button is toggled on or off, using some computed state:</p> <pre><code>local function ToggleButton(props)\n    local isButtonOn = State(false)\n\n    return New \"TextButton\" {\n        BackgroundColor3 = Computed(function()\n            if isButtonOn:get() then\n                return Color3.new(0, 1, 0) -- green when toggled on\n            else\n                return Color3.new(1, 0, 0) -- red when toggled off\n            end\n        end),\n        TextColor3 = Color3.new(0, 0, 0),\n        Text = props.message,\n\n        [OnEvent \"Activated\"] = function()\n            isButtonOn:set(not isButtonOn:get())\n        end\n    }\nend\n</code></pre> <p>With just this code, we've made our toggle button fully functional! Again, this is a regular Lua function, so nothing fancy is going on behind the scenes.</p> <p>Just like before, we can now include our toggle button in our UI easily:</p> <pre><code>local gui = New \"ScreenGui\" {\n    Name = \"ExampleGui\",\n    ZIndexBehavior = \"Sibling\",\n\n    [Children] = {\n        New \"UIListLayout\" {\n            Padding = UDim.new(0, 4)\n        },\n\n        ToggleButton {\n            message = \"Click me!\"\n        },\n\n        ToggleButton {\n            message = \"Also, click me!\"\n        },\n\n        ToggleButton {\n            message = \"Each button is independent :)\"\n        }\n    }\n}\n</code></pre> <p>Because we create a new button each time we call the function, each button keeps it's own state and functions independently.</p>"},{"location":"tutorials/further-basics/project-2/","title":"Project 2: To-Do List","text":"<p>Under construction</p> <p>This page is under construction - information may be incomplete or missing.</p>"}]}